
- concurrency refers to the idea of having many actors running independently, but not necessarily all at the same time.
- Parallelism is having actors running exactly at the same time. 
- Each Erlang process would have its own slice of time to run,



Erlang requirements: Scalability / reliability(Fault-tolerance)
The idea is thus to find good ways to handle errors and problems rather than trying to prevent them all.


** Scalability
To make it efficient, it made sense for processes to be started very quickly, to be destroyed very quickly and to be able to switch them really fast.
Having them lightweight was mandatory to achieve this.
It was also mandatory because you didn't want to have things like process pools (a fixed amount of processes you split the work between.) Instead,
it would be much easier to design programs that could use as many processes as they need.

Another important aspect of scalability is to be able to bypass your hardware's limitations by adding more hardware.

Shared memory could leave things in an inconsistent state after some crashes (especially on data shared across different nodes) and had some complications.
Instead, processes should communicate by sending messages where all the data is copied. This would risk being slower, but safer.


** Reliability
The idea is thus to find good ways to handle errors and problems rather than trying to prevent them all.
Your ideal solution in Erlang is thus to kill processes as fast as possible to avoid data corruption and transient bugs. Lightweight processes are a key element in this.
Further error handling mechanisms are also part of the language to allow processes to monitor other processes.

Second approach is distributing the program in different hardwares and also to prevent of being single point failure due to hardware crash.
Well it turns out the choice of asynchronous message passing was a good design pick there too.
Under the processes-with-asynchronous-messages model, messages are sent from one process to a second one and stored in a mailbox inside the receiving process until they are taken out to be read.
It's important to mention that messages are sent without even checking if the receiving process exists or not.
If you need to have a confirmation of delivery, you have to send a second message as a reply to the original process. 


When you design the architecture of your application, you determine which process will do which jobs, and what will depend on what.
Some processes will supervise others, some couldn't live without a twin process, etc.


Read more about run-queue and processes-migration ??
Read more about the best cases of Parallelism ??

